import os, sys
import re
import json
from pathlib import Path
import numpy as np
from f90nml.namelist import Namelist

import logging
logger = logging.getLogger(__name__)

class Content:
    def __init__(self):
        self.namelist = None
        self.cards = None
        self.textblock = None

    def write_input(self, filename, dirname="."):
        logger.debug(f"write_input: dir={dirname}, file={filename}")
        header_str = "! generated by cif2x.py\n"
        try:
            os.makedirs(Path(dirname), exist_ok=True)
            with open(Path(dirname, filename), "w") as fp:
                fp.write(header_str)
                self._write_namelist(fp)
                self._write_cards(fp)
                self._write_textblock(fp)
        except Exception as e:
            logger.error("write_input failed: {}".format(e))

    def _write_namelist(self, fp):
        logger.debug("_write_namelist")
        if self.namelist is not None:
            for key, tbl in self.namelist.items():
                _ = [ logger.warning(f"{key}.{k} is empty") for k, v in tbl.items() if v is None ]
                tbl = { k: v for k, v in tbl.items() if v is not None }

            # contents in this order
            contents = ["control", "system", "electrons", "ions", "cell", "fcp", "rism"]

            nml = {}
            for content in contents:
                if content in self.namelist.keys():
                    nml.update({content: self.namelist[content]})
            for key in self.namelist.keys():
                if key not in contents:
                    nml.update({key: self.namelist[key]})

            Namelist(nml).write(fp)

    def _write_cards(self, fp):
        logger.debug("_write_cards")
        if self.cards is not None:
            logger.debug(f">>> {self.cards}")
            for key, card in self.cards.items():
                logger.debug(f"--- key={key}, card={card}")
                if "data" in card and card["data"] is not None:
                    fp.write(to_string_block(card))
                    fp.write("\n")

    def _write_textblock(self, fp):
        logger.debug("_write_textblock")
        if self.textblock is not None:
            fp.write(self.textblock)

    def serialize(self):
        return json.dumps({
            'namelist': self.namelist,
            'cards': self.cards,
            'textblock': self.textblock,
        })

    @classmethod
    def deserialize(cls, s):
        v = json.loads(s)
        c = Content()
        c.namelist = v.get("namelist", None)
        c.cards = v.get("cards", None)
        c.textblock = v.get("textblock", None)
        return c

def inflate(content: Content):
    tbl = {}

    def _matcher(m):
        count = len(tbl) + 1
        key = f"${count}"
        matched = m.group(1)
        tbl[key] = _item_parser(matched)
        return key

    def _item_parser(s):
        # 1. range(n) or range(start, end [,step])
        is_range = re.search(r"range\((.*?)\)", s)
        if is_range:
            _a = [_to_number(_t) for _t in is_range.group(1).split(",")]
            return list(np.arange(*_a))

        # 2. [ c1, c2, ... ] (-> list) or  c1, c2, c3 (-> tuple)
        try:
            _a = ast.literal_eval(s)
            return _a
        except Exception as e:
            pass

        # 3. [ s1, s2, ... ] where s1, s2, ... are unquoted strings
        is_list = re.search(r"\[(.*?)\]", s)
        if is_list:
            _a = [_to_number(_t) for _t in is_list.group(1).split(",")]
            return _a

        # or parse failed
        raise ValueError("unable to parse item: {}".format(s))

    def _to_number(s):
        try:
            v = int(s)
            return v
        except Exception as e:
            pass
        try:
            v = float(s)
            return v
        except Exception as e:
            pass
        return s

    def _to_string(x):
        if isinstance(x, (int, float, str)):
            return str(x)
        elif isinstance(x, list):
            return "x".join([_to_string(t) for t in x])
        elif isinstance(x, dict):
            return "_".join([_to_string(k) + "-" + _to_string(v) for k,v in x.items()])
        else:
            return str(x)

    # flatten into single string
    ss = content.serialize()

    # find range keywords
    ss = re.sub("\$\{(.*?)\}", _matcher, ss)

    logger.debug("inflate: tbl={}".format(tbl))
    # logger.debug("inflate: ss={}".format(ss))

    if len(tbl) == 0:
        infos = [("", content)]
        return infos

    tbl_keys = tbl.keys()
    tbl_vals = tbl.values()

    # expand range lists
    infos = []
    for x in itertools.product(*tbl_vals):
        _map = { k: v for k, v in zip(tbl_keys, x) }
        # logger.debug("inflate: _map={}".format(_map))

        ss_new = ss
        for from_val, to_val in _map.items():
            ss_new = ss_new.replace(json.dumps(from_val), json.dumps(to_val))

        # logger.debug("inflate: ss_new={}".format(ss_new))

        content_new = Content.deserialize(ss_new)
        key = "_".join([_to_string(_) for _ in x])

        # logger.debug(f"key={key}, content_new={content_new.cards}")

        infos += [(key, content_new)]

    return infos

def to_string_block(cardinfo):
    def _stringify(x):
        if isinstance(x, str):
            return x
        elif isinstance(x, float) or isinstance(x, np.float64):
            return "{:.6f}".format(x)
        else:
            return str(x)

    retv = ""
    if "option" in cardinfo and cardinfo["option"] is not None:
        retv += "{} {{{}}}\n".format(cardinfo["key"], cardinfo["option"])
    else:
        retv += "{}\n".format(cardinfo["key"])
    if "data" in cardinfo:
        data = cardinfo["data"]
        if data is None:
            pass
        elif np.isscalar(data):
            retv += str(data) + "\n"
        else:
            for item in data:
                if np.isscalar(item):
                    retv += str(item) + "\n"
                else:
                    retv += "  ".join([_stringify(x) for x in item]) + "\n"
    return retv

